/// <reference types="nodecg-types/types/browser" />
/// <reference types="pixi.js" />
import { PrivateMessage } from "@twurple/chat";
import { gsap } from "gsap";
import { CSSRulePlugin } from "gsap/CSSRulePlugin";
import { PixiPlugin } from "gsap/PixiPlugin";
import { TextPlugin } from "gsap/TextPlugin";
import { StreamElementsEvent } from "nodecg-io-streamelements/extension/StreamElementsEvent";
import Howler, { Howl } from "howler";
import waluigiSfx from "./waah.mp3";
// import * as PIXI from "pixi.js";
import { AnimatedSprite, Container, Spritesheet } from "pixi.js";

declare global {
  var PIXI: typeof import("pixi.js");
}
// import * as PIXI from "pixi.js";

PixiPlugin.registerPIXI(PIXI);
gsap.registerPlugin(CSSRulePlugin, PixiPlugin, TextPlugin);

declare global {
  interface Window {
    __PIXI_INSPECTOR_GLOBAL_HOOK__: { register: Function };
  }
}

let waluigiSound: Howl = new Howl({
  src: [waluigiSfx],
  sprite: {
    takeThat: [0, 1200],
    wah: [1260, 1330],
    moan: [1750, 3000],
  },
});

// window.__PIXI_INSPECTOR_GLOBAL_HOOK__ && window.__PIXI_INSPECTOR_GLOBAL_HOOK__.register({ PIXI: PIXI })

// Aliases
const Application = PIXI.Application,
  Text = PIXI.Text;
let peepoScale = 1;
let peepoState = "idle";

declare global {
  interface Window {
    q: string[];
  }
}
interface Asset {
  // Generated by https://quicktype.io
  base: string;
  namespace: string;
  category: string;
  ext: string;
  name: string;
  sum: string;
  url: string;
}
const peepo = nodecg.Replicant<Asset[]>("assets:animations"),
  currScene = nodecg.Replicant<string>("currentScene", "obs");

var peepoURL: string,
  peepoStateDefault: "idle" | "move" | "talk" | "dance" = "idle";

const options = nodecg.Replicant<OptionsValue>("options");
var q = [];
window.q = q;
const peepoTalkTimers = [
  { text: "notts:Check out our !discord", title: "Discord", interval: 15 },
  // { text: 'Any Primers? WideHardo', title: 'Primers', interval: 10 },
];
let tickerIndex = 0;
var peepoIdlePos: { x: number; y: number } = { x: 0, y: 0 };
// The application will create a renderer using WebGL, if possible,0
// with a fallback to a canvas render. It will also setup the ticker
// and the root stage PIXI.Container
const app = new Application({
  width: window.innerWidth,
  height: window.innerHeight,
  backgroundAlpha: 0,
  antialias: true,
  resolution: 1,
});

let talkingText = new Text("", {
  dropShadow: true,
  dropShadowAlpha: 0.5,
  dropShadowBlur: 2,
  fill: "white",
  stroke: "black",
  strokeThickness: 4,
  fontFamily: "Inter, Arial, sans-serif",
  fontSize: "48px",
  fontWeight: "900",
});
talkingText.anchor.set(1, 0.5);

// The application will create a canvas element for you that you
// can then insert into the DOM
document.body.appendChild(app.view);
const onScene = (v: typeof currScene.value) => {
  switch (v) {
    case "Starting/Ending":
      peepoStateDefault = "dance";
      break;
    case "Mizkif Ad":
      peepoStateDefault = "move";
      break;
    default:
      peepoStateDefault = "idle";
      break;
  }
  setState(peepoStateDefault as "dance" | "move" | "idle");
};

let talking = false;
let readyToTalk = true;

var peepoSpriteSheet: Spritesheet,
  peepoSpriteIdle: AnimatedSprite,
  peepoSpriteTalk: AnimatedSprite,
  peepoSpriteMove: AnimatedSprite,
  peepoSpriteDance: AnimatedSprite,
  peepoSprites: {
    [key: string]: AnimatedSprite;
  },
  peepoSprite: Container,
  x = 0,
  y = 0;

async function setup() {
  await NodeCG.waitForReplicants(peepo, currScene).then(() => {
    peepoURL = peepo.value.find((v) => v.ext === ".json").url;
    console.log(peepoURL);
    //@ts-ignore
    window.peepoURL = peepoURL;
  });
  const atlasData = await fetch(peepoURL).then((res) => res.json());
  let rootURL = peepoURL.split("/").slice(0, -1).join("/");
  // Load Texture Atlas
  peepoSpriteSheet = new PIXI.Spritesheet(
    PIXI.BaseTexture.from(rootURL + "/" + atlasData.meta.image),
    atlasData
  );
  await peepoSpriteSheet.parse();
  // Create Animated Sprite for Idle
  peepoSpriteIdle = new PIXI.AnimatedSprite(
    peepoSpriteSheet.animations["idle"]
  );
  peepoSpriteIdle.animationSpeed = 0.25;
  peepoSpriteIdle.visible = false;

  // Create Animated Sprite for Talking
  peepoSpriteTalk = new PIXI.AnimatedSprite(
    peepoSpriteSheet.animations["talk"]
  );
  peepoSpriteTalk.animationSpeed = 0.25;
  peepoSpriteTalk.visible = false;

  // Create Animated Sprite for Moving
  peepoSpriteMove = new PIXI.AnimatedSprite(
    peepoSpriteSheet.animations["move"]
  );
  peepoSpriteMove.animationSpeed = 0.25;
  peepoSpriteMove.visible = false;

  // Create Animated Sprite for Dancing
  peepoSpriteDance = new PIXI.AnimatedSprite(
    peepoSpriteSheet.animations["dance"]
  );
  peepoSpriteDance.animationSpeed = 0.15;
  peepoSpriteDance.visible = false;

  peepoSprites = {
    idle: peepoSpriteIdle,
    talk: peepoSpriteTalk,
    move: peepoSpriteMove,
    dance: peepoSpriteDance,
  };

  // Play all Animations
  peepoSpriteTalk.play();
  peepoSpriteIdle.play();
  peepoSpriteMove.play();
  peepoSpriteDance.play();
  // Add all Animations to Container
  peepoSprite = new PIXI.Container();
  for (let i in peepoSprites) {
    let currP = peepoSprites[i];
    currP.anchor.set(1);
    currP.visible = false;
    peepoSprite.addChild(peepoSprites[i]);
  }
  // Add peepo & text to stage
  app.stage.addChild(peepoSprite, talkingText);
  app.ticker.minFPS = 10;
  app.ticker.maxFPS = 60;
  peepoSpriteIdle.visible = true;

  // Set position of peepo to bottom right corner of screen
  peepoSprite.pivot.set(0.5);
  peepoSprite.setTransform(app.view.width - 42, app.view.height - 42);
  peepoIdlePos = { x: app.view.width - 42, y: app.view.height - 42 };
  x = peepoSprite.x;
  y = peepoSprite.y;

  app.ticker.add(draw).add(peepoTicker, textFadeOut);

  currScene.on("change", onScene);
  NodeCG.waitForReplicants(options).then(() => {
    onOptionsChanged(options.value);
  });

  setTimeout(runTicker, 60000 * (Math.random() * 5 + 5));
}

setup();

let elapsed = 0.0;
function draw(deltaTime: number) {
  elapsed += deltaTime;
}

nodecg.listenFor("alert", "simple-alerts", onAlert);

window.addEventListener("click", function (event) {
  q.push("That Tickles, bitch!");
});

function setState(state: "idle" | "talk" | "move" | "dance") {
  if (state === peepoState) return;
  peepoSprites[peepoState].visible = false;
  peepoState = state;
  peepoSprites[peepoState].visible = true;

  switch (state) {
    case peepoStateDefault:
      setTimeout(() => {
        readyToTalk = true;
      }, 500);
      return;
    case "talk":
      break;
    case "move":
      break;
    case "dance":
      break;
  }

  readyToTalk = false;
}

interface PeepoTalkProp {
  text: string;
  tts: boolean;
  animation: string;
}
async function peepoTalk(text: string) {
  let ttson = true;
  if (text.length > 400) return;
  if (text.startsWith("notts:")) {
    text = text.replace("notts:", "");
    ttson = false;
  }
  const nextLetter = (i: number) => {
    if (i < text.length) {
      talkingText.text = text.slice(0, i + 1);
      setTimeout(() => {
        nextLetter(i + 1);
      }, 50);
    } else {
      talkingText.text = text;
      setTimeout(() => {
        setState(peepoStateDefault);
        talkingText.text = "";
      }, 2000);
    }
  };
  setState("talk");
  nextLetter(0);
  if (ttson) ttsSpeak(text);
}

let ttsEnabled = true;
async function ttsSpeak(text: string) {
  if (!ttsEnabled || !text || text === "") {
    console.debug("TTS Disabled, skipping %d", text);
    return;
  }
  let speak = await new Promise<string>((resolve, reject) => {
    nodecg.sendMessageToBundle(
      "tts-process",
      "simple-alerts",
      text,
      (err, data: string) => {
        if (err) reject(err);
        resolve(data);
      }
    );
  });

  if (speak.length === 0) {
    nodecg.log.warn(speak);
    return;
  }

  document.getElementById("source").setAttribute("src", speak);
  let audio = document.getElementById("audio") as HTMLAudioElement;
  audio.pause();
  audio.load();
  audio.play();
}

interface OptionsValue {
  peepoSize: number;
  filters: RegExp[];
  tts: boolean;
  position: {
    x: number | undefined;
    y: number | undefined;
  };
}
const onOptionsChanged = (msg: OptionsValue) => {
  console.debug(peepoSprite?.scale);
  console.debug(msg);
  const pos = msg.position;
  if (pos.x !== undefined && pos.y !== undefined) {
    x = pos.x;
    y = pos.y;
  } else {
    msg.position = { x, y };
  }
  peepoScale = 1 * msg.peepoSize;
  ttsEnabled = msg.tts;
  peepoSprite?.setTransform(x, y, peepoScale, peepoScale);
  talkingText.x = peepoSprite?.x - peepoSprite?.width - 10;
  talkingText.y = peepoSprite?.y - peepoSprite?.height / 2;
};

options.on("change", onOptionsChanged);

async function onAlert(data: StreamElementsEvent) {
  const filter = (toFilter: string): string => {
    let regexTested = options.value.filters.filter((regx) =>
      regx.test(toFilter)
    );
    let newText =
      regexTested.length > 0
        ? `ðŸ™… Screw you @${regexTested[0].exec(toFilter)[0]}. Get out ðŸ˜¥`
        : toFilter;
    return newText;
  };
  if (
    data.provider === "twitch" &&
    /(follow|cheer|subscriber|tip|raid|host)/g.test(data.type)
  ) {
    let talk = `Thanks ${
      data.type === "subscriber" && data.data.gifted
        ? data.data.sender
        : data.data.displayName
    } for `;
    switch (data.type) {
      case "follow":
        talk += "the follow! ðŸ’–";
        if (data.data.displayName.match(/hoss[0-9]*/gi)) {
          talk = `ðŸ™… Screw you @${data.data.displayName}. Get out ðŸ˜¥`;
        }
        break;
      case "cheer":
        10;
        talk += `the fat ${data.data.amount} BITTIES!`;
        break;
      case "host":
        talk += `the ${data.data.amount} viewer host! ðŸŽ‰`;
        break;
      case "raid":
        talk += `the ${data.data.amount} viewer raid! ðŸ¥³`;
        break;
      case "subscriber":
        talk += data.data.gifted
          ? `${data.data.quantity} giftie${data.data.quantity > 1 ? "s" : ""}`
          : data.data.months > 1
          ? `${data.data.months} months of support! ðŸŽ‰`
          : `your epic sub! ðŸ¥³`;
        break;
      case "tip":
        talk += `${data.data.currency}${data.data.amount} ðŸ¤‘!`;
    }
    talk = "notts:" + talk;
    q.push(talk);
  } else {
  }
}

function peepoTicker() {
  if (readyToTalk && q.length > 0) {
    console.debug("Calling peepoTalk with requested text: ", q[0]);
    peepoTalk(q.shift());
  }
}

function runTicker() {
  q.push(peepoTalkTimers[tickerIndex++].text);
  if (tickerIndex >= peepoTalkTimers.length) {
    tickerIndex = 0;
  }
  setTimeout(runTicker, 60000 * (Math.random() * 5 + 5));
}

function textFadeOut(delta) {
  if (talkingText.text !== "" && !talking) {
    gsap.to(talkingText, { pixi: { alpha: 0 }, duration: 0.5 });
  } else {
    gsap.set(talkingText, { pixi: { alpha: 1 } });
  }
}

interface ChatCommandHandler {
  channel: string;
  user: string;
  message: string;
  _msg: PrivateMessage;
}
const commands = [
  {
    data: {
      channel: "#devjimmyboy",
      command: "yo",
      exMarkReq: false,
      bundleName: nodecg.bundleName,
    },
    handler: (data: ChatCommandHandler) => {
      q.push(`Yo, ${data.user}!`);
    },
  },
  {
    data: {
      channel: "#devjimmyboy",
      command: "dance",
      exMarkReq: false,
      bundleName: nodecg.bundleName,
    },
    handler: (data: ChatCommandHandler) => {
      setState("dance");
      setTimeout(() => setState("idle"), 5000);
    },
  },
  {
    data: {
      channel: "#devjimmyboy",
      command: ["dumb broad", "pakoneesh"],
      exMarkReq: false,
      bundleName: nodecg.bundleName,
    },
    handler: (data: ChatCommandHandler) => {
      q.push(`my wife left me, and took the kids with her.`);
      q.push(`${data.user}, I really need some money.`);
    },
  },
  {
    data: {
      channel: "#devjimmyboy",
      command: "mongus",
      exMarkReq: false,
      bundleName: nodecg.bundleName,
    },
    handler: (data: ChatCommandHandler) => {
      q.push(`@${data.user}, U sussy baka (^UwU^)`);
    },
  },
  {
    data: {
      channel: "#devjimmyboy",
      command: "joe",
      exMarkReq: false,
      bundleName: nodecg.bundleName,
    },
    handler: (data: ChatCommandHandler) => {
      q.push(`@${data.user}, joe mama`);
    },
  },
  {
    data: {
      channel: "#devjimmyboy",
      command: "custom",
      exMarkReq: false,
      bundleName: nodecg.bundleName,
    },
    handler: (data: ChatCommandHandler) => {
      q.push(`${data.message.replace(/!?custom/, "")}`);
    },
  },
  {
    data: {
      channel: "#devjimmyboy",
      command: "wawaweewa",
      exMarkReq: false,
      bundleName: nodecg.bundleName,
    },
    handler: (data: ChatCommandHandler) => {
      waluigiSound.volume(0.5);
      const soundSprite = sounds[Math.floor(Math.random() * sounds.length)];
      waluigiSound.play(soundSprite);
    },
  },
];
const sounds = ["wah", "takeThat", "moan"];
let timeout = false;

nodecg.listenFor(`chat-message`, "twitch", (data: ChatCommandHandler) => {
  // console.debug(data)

  commands.forEach((val) => {
    let regex = [];
    if (typeof val.data.command === "string") {
      regex.push(
        new RegExp(
          `\\b${val.data.exMarkReq ? "\\!" : "!?" + val.data.command}\\b`,
          "gi"
        )
      );
    } else if (typeof val.data.command.forEach === "function") {
      val.data.command.forEach((cmd) => {
        regex.push(
          new RegExp(`\\b${val.data.exMarkReq ? "!" : "!?" + cmd}\\b`, "gi")
        );
      });
    }
    if (
      data.channel === val.data.channel &&
      regex.some((r) => r.test(data.message))
    ) {
      val.handler(data);
    }
  });
});

nodecg.listenFor("peepoTalkOnDemand", (msg) => q.push(msg));
nodecg.listenFor("peepoPosReset", () => {
  options.value.position.x = app.view.width - 42;
  options.value.position.y = app.view.height - 42;
});

let prevPos = [];
const peepoTl = gsap.timeline({});
const heatClick = (clickData: {
  x: string;
  y: string;
  id: string;
  user:
    | {
        display_name: string;
      }
    | undefined;
}) => {
  if (timeout) return;
  else timeout = true;
  setTimeout(() => {
    timeout = false;
  }, 1500);
  console.debug("clickData: ", clickData);
  let winX = parseFloat(clickData.x) * window.innerWidth;
  let winY = parseFloat(clickData.y) * window.innerHeight;
  prevPos.push(options.value.position);
  peepoTl
    .to(peepoSprite, {
      pixi: {
        x: winX + (peepoSprite.width / 2) * 1.5,
        y: winY + 25,
        scale: peepoScale * 1.5,
      },
      delay: 0.5,
      onStart: () => setState("move"),
      onComplete: () => setState("dance"),
      duration: 1.5,
    })
    .to(peepoSprite, {
      pixi: {
        x: prevPos[0]?.x || peepoIdlePos.x,
        y: prevPos[0]?.y || peepoIdlePos.x,
        scale: peepoScale,
      },
      delay: 1,
      duration: 1,
      onStart: () => setState("move"),
      onComplete: () => {
        prevPos.shift();
        if (prevPos.length === 0) {
          setState("idle");
        }
      },
    });
};

nodecg.listenFor("click", "heat", heatClick);
nodecg.listenFor("stopPls", () => {
  let audio = document.getElementById("audio") as HTMLAudioElement;
  audio.pause();
});
