/// <reference path="../../../../types/browser.d.ts" />

import * as PIXI from "pixi.js";
import { StreamElementsEvent } from "nodecg-io-streamelements/extension/types";
import { gsap } from "gsap";
import { CSSRulePlugin } from "gsap/CSSRulePlugin";
import { PixiPlugin } from "gsap/PixiPlugin";
import { TextPlugin } from "gsap/TextPlugin";
PixiPlugin.registerPIXI(PIXI);
gsap.registerPlugin(CSSRulePlugin, PixiPlugin, TextPlugin);

declare global {
	interface Window {
		__PIXI_INSPECTOR_GLOBAL_HOOK__: { register: Function };
	}
}

window.__PIXI_INSPECTOR_GLOBAL_HOOK__ &&
	window.__PIXI_INSPECTOR_GLOBAL_HOOK__.register({ PIXI: PIXI });

// Aliases
const Application = PIXI.Application,
	Container = PIXI.Container,
	Text = PIXI.Text,
	loader = PIXI.Loader.shared,
	resources = PIXI.Loader.shared.resources,
	Sprite = PIXI.Sprite;
let peepoScale = 1;
let peepoState = "idle";

declare global {
	interface Window {
		q: string[];
	}
}
interface Asset {
	// Generated by https://quicktype.io
	base: string;
	namespace: string;
	category: string;
	ext: string;
	name: string;
	sum: string;
	url: string;
}
const peepo = nodecg.Replicant<Asset[]>("assets:animations");
let peepoURL;

const options = nodecg.Replicant<OptionsValue>("options");
var q = [];
window.q = q;
const peepoTalkTimers = [
	{ text: "notts:Check out our !discord", title: "Discord", interval: 15 },
	{ text: "Any Primers? WideHardo", title: "Primers", interval: 10 },
];
let tickerIndex = 0;
// The application will create a renderer using WebGL, if possible,
// with a fallback to a canvas render. It will also setup the ticker
// and the root stage PIXI.Container
const app = new PIXI.Application({
	width: window.innerWidth,
	height: window.innerHeight,
	backgroundAlpha: 0,
	antialias: true,
	resolution: 1,
});

let talkingText = new PIXI.Text("", {
	dropShadow: true,
	dropShadowAlpha: 0.5,
	dropShadowBlur: 2,
	fill: "white",
	stroke: "black",
	strokeThickness: 4,
	fontFamily: "Inter, Arial, sans-serif",
	fontSize: "48px",
	fontWeight: "900",
});
talkingText.anchor.set(1, 0.5);

// The application will create a canvas element for you that you
// can then insert into the DOM
document.body.appendChild(app.view);

NodeCG.waitForReplicants(peepo).then(() => {
	peepoURL = peepo.value.find((v) => v.ext === ".json").url;
	PIXI.Loader.shared.add(peepoURL).load(setup);
});
let talking = false;
let readyToTalk = true;

var peepoSpriteSheet: PIXI.Spritesheet,
	peepoSpriteIdle: PIXI.AnimatedSprite,
	peepoSpriteTalk: PIXI.AnimatedSprite,
	peepoSpriteMove: PIXI.AnimatedSprite,
	peepoSpriteDance: PIXI.AnimatedSprite,
	peepoSprites: {
		idle: PIXI.AnimatedSprite;
		talk: PIXI.AnimatedSprite;
		move: PIXI.AnimatedSprite;
		dance: PIXI.AnimatedSprite;
	},
	peepoSprite: PIXI.Container,
	x = 0,
	y = 0;

function setup() {
	// Load Texture Atlas
	peepoSpriteSheet = PIXI.Loader.shared.resources[peepoURL].spritesheet;
	// Create Animated Sprite for Idle
	peepoSpriteIdle = new PIXI.AnimatedSprite(
		peepoSpriteSheet.animations["idle"]
	);
	peepoSpriteIdle.animationSpeed = 0.25;
	// Create Animated Sprite for Talking
	peepoSpriteTalk = new PIXI.AnimatedSprite(
		peepoSpriteSheet.animations["talk"]
	);
	peepoSpriteTalk.animationSpeed = 0.25;

	// Create Animated Sprite for Moving
	peepoSpriteMove = new PIXI.AnimatedSprite(
		peepoSpriteSheet.animations["move"]
	);
	peepoSpriteMove.animationSpeed = 0.25;

	// Create Animated Sprite for Dancing
	peepoSpriteDance = new PIXI.AnimatedSprite(
		peepoSpriteSheet.animations["dance"]
	);
	peepoSpriteDance.animationSpeed = 0.15;

	peepoSprites = {
		idle: peepoSpriteIdle,
		talk: peepoSpriteTalk,
		move: peepoSpriteMove,
		dance: peepoSpriteDance,
	};

	// Play both Animations
	peepoSpriteTalk.play();
	peepoSpriteIdle.play();
	peepoSpriteMove.play();
	peepoSpriteDance.play();
	// Add both Animations to Container
	peepoSprite = new PIXI.Container();
	for (let i in peepoSprites) {
		let currP = peepoSprites[i];
		currP.anchor.set(1, 1);
		currP.visible = false;
		peepoSprite.addChild(peepoSprites[i]);
	}
	// Add peepo & text to stage
	app.stage.addChild(peepoSprite, talkingText);
	app.ticker.minFPS = 10;
	app.ticker.maxFPS = 144;
	peepoSpriteIdle.visible = true;

	// Set position of peepo to bottom right corner of screen
	peepoSprite.pivot.set(0.5);
	peepoSprite.setTransform(app.view.width - 42, app.view.height - 42);
	x = peepoSprite.x;
	y = peepoSprite.y;

	app.ticker.add(draw).add(peepoTicker, textFadeOut); //.add(textFadeOut);

	NodeCG.waitForReplicants(options).then(() => {
		onOptionsChanged(options.value);
	});

	setTimeout(runTicker, 60000 * (Math.random() * 5 + 5));
}

let elapsed = 0.0;
function draw(deltaTime: number) {
	elapsed += deltaTime;
}

nodecg.listenFor("alert", "simple-alerts", onAlert);

window.addEventListener("click", function (event) {
	q.push("That Tickles, bitch!");
});

function setState(state: "idle" | "talk" | "move" | "dance") {
	if (state === peepoState) return;
	peepoSprites[peepoState].visible = false;
	peepoState = state;
	peepoSprites[peepoState].visible = true;

	switch (state) {
		case "idle":
			setTimeout(() => {
				readyToTalk = true;
			}, 500);
			return;
		case "talk":
			break;
		case "move":
			break;
		case "dance":
			break;
	}

	readyToTalk = false;
}

interface PeepoTalkProp {
	text: string;
	tts: boolean;
	animation: string;
}
async function peepoTalk(text: string) {
	let ttson = true;
	if (text.length > 400) return;
	if (text.startsWith("notts:")) {
		text = text.replace("notts:", "");
		ttson = false;
	}
	const nextLetter = (i: number) => {
		if (i < text.length) {
			talkingText.text = text.slice(0, i + 1);
			setTimeout(() => {
				nextLetter(i + 1);
			}, 50);
		} else {
			talkingText.text = text;
			setTimeout(() => {
				setState("idle");
				talkingText.text = "";
			}, 2000);
		}
	};
	setState("talk");
	nextLetter(0);
	if (ttson) ttsSpeak(text);
}

let ttsEnabled = true;
async function ttsSpeak(text: string) {
	if (!ttsEnabled || !text || text === "") {
		console.debug("TTS Disabled, skipping %d", text);
		return;
	}
	let speak = await fetch(
		"https://api.streamelements.com/kappa/v2/speech?voice=Brian&text=" +
			encodeURIComponent(text.trim()),
		{ mode: "cors" }
	);

	if (speak.status != 200) {
		nodecg.log.warn(await speak.text());
		return;
	}

	let mp3 = await speak.blob();
	let blobUrl = URL.createObjectURL(mp3);
	document.getElementById("source").setAttribute("src", blobUrl);
	let audio = document.getElementById("audio") as HTMLAudioElement;
	audio.pause();
	audio.load();
	audio.play();
}

interface OptionsValue {
	peepoSize: number;
	filters: RegExp[];
	tts: boolean;
}
const onOptionsChanged = (msg: OptionsValue) => {
	console.debug(peepoSprite?.scale);
	console.debug(msg);
	peepoScale = 1 * msg.peepoSize;
	ttsEnabled = msg.tts;
	peepoSprite?.setTransform(x, y, peepoScale, peepoScale);
	talkingText.x = peepoSprite?.x - peepoSprite?.width - 10;
	talkingText.y = peepoSprite?.y - peepoSprite?.height / 2;
};

options.on("change", onOptionsChanged);

async function onAlert(data: StreamElementsEvent) {
	const filter = (toFilter: string): string => {
		if (!options.value.filters)
			options.value.filters = [/(hoss00312)_?.*?\s/gi];
		let regexTested = options.value.filters.filter((regx) =>
			regx.test(toFilter)
		);
		let newText =
			regexTested.length > 0
				? `ðŸ™… Screw you @${
						regexTested[0].exec(toFilter)[0]
				  }. Get out ðŸ˜¥`
				: toFilter;
		return newText;
	};
	if (
		data.provider === "twitch" &&
		/(follow|cheer|subscriber|tip|raid|host)/g.test(data.type)
	) {
		let talk = `Thanks ${
			data.type === "subscriber" && data.data.gifted
				? data.data.sender
				: data.data.displayName
		} for `;
		switch (data.type) {
			case "follow":
				talk += "the follow! ðŸ’–";
				if (data.data.displayName.match(/hoss[0-9]*/gi)) {
					talk = `ðŸ™… Screw you @${data.data.displayName}. Get out ðŸ˜¥`;
				}
				break;
			case "cheer":
				10;
				talk += `the fat ${data.data.amount} BITTIES!`;
				break;
			case "host":
				talk += `the ${data.data.amount} viewer host! ðŸŽ‰`;
				break;
			case "raid":
				talk += `the ${data.data.amount} viewer raid! ðŸ¥³`;
				break;
			case "subscriber":
				talk += data.data.gifted
					? `${data.data.quantity} giftie${
							data.data.quantity > 1 ? "s" : ""
					  }`
					: data.data.months > 1
					? `${data.data.months} months of support! ðŸŽ‰`
					: `your epic sub! ðŸ¥³`;
				break;
			case "tip":
				talk += `${data.data.currency}${data.data.amount} ðŸ¤‘!`;
		}
		talk = "notts:" + talk;
		q.push(talk);
	} else {
	}
}

function peepoTicker() {
	if (readyToTalk && q.length > 0) {
		console.debug("Calling peepoTalk with requested text: ", q[0]);
		peepoTalk(q.shift());
	}
}

function runTicker() {
	q.push(peepoTalkTimers[tickerIndex++].text);
	if (tickerIndex >= peepoTalkTimers.length) {
		tickerIndex = 0;
	}
}

function textFadeOut(delta) {
	if (talkingText.text !== "" && !talking) {
		gsap.to(talkingText, { pixi: { alpha: 0 }, duration: 0.5 });
	}
}

interface ChatCommandHandler {
	channel: string;
	user: string;
	message: string;
	_msg: import("../../../twitch-chat/node_modules/twitch-chat-client/lib/StandardCommands/TwitchPrivateMessage").TwitchPrivateMessage;
}
const commands = [
	{
		data: {
			channel: "#devjimmyboy",
			command: "yo",
			exMarkReq: false,
			bundleName: nodecg.bundleName,
		},
		handler: (data: ChatCommandHandler) => {
			q.push(`Yo, ${data.user}!`);
		},
	},
	{
		data: {
			channel: "#devjimmyboy",
			command: "dance",
			exMarkReq: false,
			bundleName: nodecg.bundleName,
		},
		handler: (data: ChatCommandHandler) => {
			setState("dance");
			setTimeout(() => setState("idle"), 5000);
		},
	},
	{
		data: {
			channel: "#devjimmyboy",
			command: ["dumb broad", "pakoneesh"],
			exMarkReq: false,
			bundleName: nodecg.bundleName,
		},
		handler: (data: ChatCommandHandler) => {
			q.push(`my wife left me, and took the kids with her.`);
			q.push(`${data.user}, I really need some money.`);
		},
	},
	{
		data: {
			channel: "#devjimmyboy",
			command: "mongus",
			exMarkReq: false,
			bundleName: nodecg.bundleName,
		},
		handler: (data: ChatCommandHandler) => {
			q.push(`@${data.user}, U sussy baka (^UwU^)`);
		},
	},
	{
		data: {
			channel: "#devjimmyboy",
			command: "joe",
			exMarkReq: false,
			bundleName: nodecg.bundleName,
		},
		handler: (data: ChatCommandHandler) => {
			q.push(`@${data.user}, joe mama`);
		},
	},
	{
		data: {
			channel: "#devjimmyboy",
			command: "custom",
			exMarkReq: false,
			bundleName: nodecg.bundleName,
		},
		handler: (data: ChatCommandHandler) => {
			q.push(`${data.message.replace(/!?custom/, "")}`);
		},
	},
];

nodecg.listenFor(`chat-message`, "twitch-chat", (data: ChatCommandHandler) => {
	console.debug(data);
	commands.forEach((val) => {
		let regex = [];
		if (typeof val.data.command === "string") {
			regex.push(
				new RegExp(
					`\\b${
						val.data.exMarkReq ? "\\!" : "!?" + val.data.command
					}\\b`,
					"gi"
				)
			);
		} else if (typeof val.data.command.forEach === "function") {
			val.data.command.forEach((cmd) => {
				regex.push(
					new RegExp(
						`\\b${val.data.exMarkReq ? "!" : "!?" + cmd}\\b`,
						"gi"
					)
				);
			});
		}
		if (
			data.channel === val.data.channel &&
			regex.some((r) => r.test(data.message))
		) {
			val.handler(data);
		}
	});
});

nodecg.listenFor("peepoTalkOnDemand", (msg) => q.push(msg));

let prevPos = [];
const peepoTl = gsap.timeline({});
const heatClick = (clickData) => {
	console.debug("clickData: ", clickData);
	let winX = parseFloat(clickData.x) * window.innerWidth;
	let winY = parseFloat(clickData.y) * window.innerHeight;
	prevPos.push(peepoSprite.position.clone());
	peepoTl
		.to(peepoSprite, {
			pixi: { x: winX, y: winY, scale: peepoScale * 1.5 },
			delay: 0.5,
			onStart: () => setState("move"),
			onComplete: () => setState("dance"),
			duration: 1.5,
		})
		.to(peepoSprite, {
			pixi: { x: prevPos[0].x, y: prevPos[0].y, scale: peepoScale },
			delay: 1,
			duration: 1,
			onStart: () => setState("move"),
			onComplete: () => {
				prevPos.shift();
				if (prevPos.length === 0) {
					setState("idle");
				}
			},
		});
};

nodecg.listenFor("click", "heat", heatClick);
nodecg.listenFor("stopPls", () => {
	let audio = document.getElementById("audio") as HTMLAudioElement;
	audio.pause();
});
