/// <reference types="node" />
declare module "fakeyou.js" {
  class Group<K, T> extends Map<K, T> {
    /**
     * Checks if all items passes the function, equals to Array.every()
     * @param fn The function to test each item
     * @param arg Value to use as this in the function
     */
    every(fn: (val: T) => boolean, arg?: T): boolean;
    /**
     * Find values an gets a group with found items, equals to Array.filter()
     * @param fn The function to evaluate.
     * @param arg Value to use as this when executing the function.
     */
    filter(fn: (val: T) => boolean, arg?: T): Group<string, T>;
    /**
     * Find values an gets the first found result, equals to Array.find()
     * @param fn The function to evaluate
     * @param arg Value to use as this when executing the function.
     */
    find(fn: (val: T) => boolean, arg?: T): T | null;

    /**
     * Obtains the first item(s) of the group
     * @param count The amount of items
     */
    first(count?: number): T | T[];
    /**
     * Obtains the last item(s) of the group
     * @param count The amount of items
     */
    last(count?: number): T | T[];
    /**
     * Creates a new array with results of given function in each item, equals to Array.map()
     * @param fn The function to test each item
     * @param arg Value to use as this in the function
     */
    map<E>(fn: (val: T) => E, arg?: T): E[];
    /**
     * Checks if at least one item passes the function, equals to Array.some()
     * @param fn The function to test each item
     * @param arg Value to use as this in the function
     */
    some(fn: (val: T) => boolean, arg?: T): boolean;
    /**
     * Generate an array of values of this group
     */
    toArray(): T[];
  }

  /**
   * Represents a FakeYou leaderboard
   */
  class LeaderBoard {
    constructor(client: Client, data: APIData);
    client: Client;
    /**
     * The group of info this leaderboard has
     */
    group: Group<string, LeaderBoardItem>;
    /**
     * Obtains an item based on its position in the leaderboard
     * @param position The position to get
     * @param isw2l If the item is from w2l leaderboard
     */
    getPosition(position: number, isw2l?: boolean): LeaderBoardItem;
    /**
     * Gets the TTS leaderboard
     */
    tts(): Group<string, LeaderBoardItem>;
    /**
     * Gets the W2L leaderboard
     */
    w2l(): Group<string, LeaderBoardItem>;
    /**
     * Generates an array that contains username and count info
     */
    toArray(): string[];
  }

  /**
   * The list of badges of a user
   */
  class Badges {
    /**
     *
     * @param client The client that instantiated this
     * @param user The user this belongs to
     * @param data The badges data
     */
    constructor(client: Client, user: User, data: APIData);
    /**
     * The client that instantiated this
     */
    client: Client;
    /**
     * The user this belongs to
     */
    user: User;
    /**
     * The group of badges this user has
     */
    group: Group<string, BadgeInfo>;
  }

  class ClientUser extends User {
    constructor(client: Client, data: APIData);
    isBanned: boolean;
    isMod: boolean;
    plan: string;
    /**
     * Edit the client user info
     * @param options The client user options to edit
     *
     * *You can set a value as null to remove it*
     */
    edit(options: ClientEditOptions): Promise<ClientUser>;
    /**
     * Get the models made by the client user
     */
    ttsModels(): Promise<Group<string, Model>>;
    /**
     * Get the TTS results generated by the client user
     */
    ttsResults(): Promise<Group<string, TTSResult>>;
  }
  class User {
    client: Client;
    token: string;
    username: string;
    displayName: string;
    gravatarHash: string;
    createdAt: Date | null;
    badges: Badges | null;
    description: string | null;
    links: {
      twitter: string | null;
      discord: string | null;
      github: string | null;
      twitch: string | null;
      patreon: string | null;
      cashapp: string | null;
      website: string | null;
    };
    ttsVisibility: boolean | null;
    w2lVisibility: boolean | null;
    partial: boolean;
    createdTimestamp: number | null;
    isVisible(isw2l: boolean): boolean;
    gravatarURL(): string;
    profileURL(): string;
  }

  class Model {
    algorithm: string | null;
    category: string[] | null;
    categoryTokens: string[] | null;
    client: Client;
    count: number | null;
    createdAt: Date | null;
    createdTimestamp: number | null;
    description: string | null;
    features: ModelFeatures;
    lang: string;
    locate: string;
    name: string | null;
    partial: boolean;
    pipeline: string | null;
    setVisibility: Visibility | null;
    title: string;
    token: string;
    type: "model";
    updatedAt: Date | null;
    updatedTimestamp: number | null;
    user: User | null;
    userToken: string | null;
    vocoder: string | null;
    fetch(): Promise<Model>;
    isVisible(isw2l: boolean): boolean | null;
    modelURL(): string;
    /**
     * Make a TTS request
     * @param text The text to speech
     */
    request(text: string): Promise<TTSResult>;
  }

  /**
   * Represents a category on FakeYou
   */
  class Category {
    constructor(client: Client, data: APIData);
    client: Client;
    /**
     * The date the category was created
     */
    createdAt: Date | null;
    /**
     * The timestamp in seconds the category was created
     */
    createdTimestamp: number | null;
    /**
     * The data about features this category has
     */
    features: CategoryFeatures;
    /**
     * The group of models this belongs to
     */
    models: Group<string, Model>;
    /**
     * An alternative title if is contextually different
     */
    name: string | null;
    /**
     * Checks if has partial data
     */
    partial: boolean;
    /**
     * The group of children categories this belongs to
     */
    subCategories: Group<string, Category>;
    /**
     * The parent category in which this category is located
     */
    superCategory: Category | null;
    /**
     * The parent category token in which this category is located
     */
    superCategoryToken: string | null;
    /**
     * The token of this category
     */
    token: string;
    /**
     * The type of this category
     */
    type: string;
    /**
     * The date that category was last updated
     */
    updatedAt: Date | null;
    /**
     * The timestamp in seconds the category was last updated
     */
    updatedTimestamp: number | null;
    /**
     * The user was created the category
     */
    user: User | null;
    /**
     * The user token was created the category
     */
    userToken: string | null;
    /**
     * Checks if is a super category
     */
    isSuperCategory(): boolean;
    /**
     * Checks if is a sub category (has parent)
     */
    isSubCategory(): boolean;
    /**
     * Get all data about this category
     */
    fetch(): Promise<Category>;
  }

  class ModelManager {
    constructor(client: Client);
    cache: Group<string, Model>;
    client: Client;
    /**
     * Get all data about a model
     * @param modelToken The model token
     */
    fetch(modelToken: string): Promise<Model>;
    /**
     * Resolves a model data to a model object
     * @param model The title, name or token of the model
     */
    resolve(model: string): Model;
  }

  class CategoryManager {
    constructor(client: Client);
    /**
     * The group of cached category items mapped by their tokens
     */
    cache: Group<string, Category>;
    client: Client;
    /**
     * Get all data about a category
     * @param token The category token
     */
    fetch(token: string): Promise<Category>;
    /**
     * Resolves a category data to a category object
     * @param category The title, name or token of category
     */
    resolve(category: string): Category;
  }

  class TTSResult {
    attempts: number;
    audioPath: string | null;
    client: Client;
    createdAt: Date | null;
    createdTimestamp: number | null;
    duration: number | null;
    model: Model;
    modelToken: string;
    partial: boolean;
    set setVisibilty(visibility: Visibility | null);
    spectrogramPath: string | null;
    size: number | null;
    text: string;
    token: string;
    type: "tts";
    updatedAt: Date | null;
    updatedTimestamp: number | null;
    vocoder: string | null;
    worker: string | null;
    audioURL(): string | null;
    fetch(): Promise<TTSResult>;
    getAudio(): Promise<Buffer>;
    getSpectrogram(): Promise<Spectogram>;
    resultURL(): string | null;
    spectrogramURL(): string | null;
    isVisible(): boolean | null;
  }

  /**
   * Manage API results methods and holds their cache
   */
  class ResultManager {
    constructor(client: Client);
    /**
     * The group of cached result items mapped by their tokens
     */
    cache: Group<string, TTSResult>;
    client: Client;
    /**
     * Get all data about a model
     * @param token The result token
     */
    fetch(token: string): Promise<TTSResult>;
    /**
     * Resolves a model data to a model object
     * @param token The text, token or audio path of the model
     */
    resolve(token: string): TTSResult;
  }
  interface ClientOptions {
    /**
     * The password of your FakeYou account
     */
    password?: string;
    /**
     * The authorization token
     */
    token?: string;
    /**
     * The username or e-mail of you FakeYou account
     */
    usernameOrEmail?: string;
  }

  /**
   * The main hub to interact with FakeYouAPI
   *
   * ### IMPORTANT
   *
   * **You need to forcely use start() method to get important data from API and login if needed**
   */
  export class Client {
    constructor(options?: ClientOptions);
    categories: CategoryManager;
    models: ModelManager;
    isReady: boolean;
    results: ResultManager;
    token: string;
    user: ClientUser | null;
    /**
     * Fetch all data about an user
     * @param username Profile username
     */
    fetchUser(username: string): Promise<User>;
    /**
     * Obtains the TTS/W2L leaderboard
     */
    leaderboard(): Promise<LeaderBoard>;
    /**
     * Generate a TTS request
     * @param model Name, object or token of model
     * @param text The text to speech
     */
    makeTTS(model: string, text: string): Promise<TTSResult>;
    /**
     * Get info about TTS queued
     */
    queue(): Promise<QueueInfo>;
    /**
     * Search an model
     * @param query The model name
     */
    searchModel(query: string): Group<string, Model>;
    /**
     * #### IMPORTANT
     * **You need to forcely use start() method to get important data from API and login if needed**
     */
    start(): Promise<Client>;
  }

  export const version: string;
  export enum Visibility {
    PUBLIC = "public",
    HIDDEN = "hidden",
  }

  interface CategoryFeatures {
    /**
     * If can directly have models on it
     */
    canHaveModels: boolean;
    /**
     * If can have subcategories (is super category)
     */
    canHaveSubcategories: boolean;
    /**
     * If can only mods apply
     */
    canOnlyMods: boolean;
  }

  interface Spectogram {
    mel: number[];
    melScaled: number[];
  }

  interface QueueInfo {
    /**
     * The queue count
     */
    count: number;
    /**
     * The last cache time
     */
    time: Date;
  }

  /**
   * Info about model extra features
   */
  interface ModelFeatures {
    frontPageFeatured?: boolean;
    lockedFromUse?: boolean;
    lockedFormUserModification?: boolean;
    /**
     * Good for streams
     */
    twitchFeatured?: boolean;
  }

  interface ClientEditOptions {
    description: string;
    ttsVisibility: boolean;
    w2lVisibility: boolean;
    cashapp: string;
    discord: string;
    github: string;
    twitch: string;
    twitter: string;
    website: string;
  }

  interface LeaderBoardItem {
    /**
     * The queue count
     */
    count: number;
    /**
     * The leaderboard position
     */
    position: number;
    /**
     * The user this belongs to
     */
    user: User;
    /**
     * The item type
     */
    type: string;
  }
  interface BadgeInfo {
    /**
     * The title of the badge.
     */
    title: string;
    /**
     * Badge key identifier.
     */
    slug: string;
    /**
     * The badge description.
     */
    description: string;
    /**
     * The badge image URL.
     */
    imageURL: string;
    /**
     * The date when this badge was granted.
     */
    createdAt: Date;
  }

  /**
   * Data from the FakeYou api.
   */
  type APIData = Record<string, any>;
}
